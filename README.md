## Sample To Do Application

From this URL: [Hoang Pham - Build a Rails backend API for an iPhone client](http://pnhoang.tumblr.com/post/24160454924/build-a-rails-backend-api-for-an-iphone-client)


---

I have been an iOS developer for over three years, but I am a newcomer to Rails. I think the best way to learn Rails is to do a sample Todo list app with RESTFUL API and basic authentication, and because I want to review my iOS skills, I will write an iOS client to query the server&#8217;s API to show on the iPhone and iPad. Along the way, I will document the process of making these two projects and the source code for all two of them will be available on my Github account
 The purpose of this entry is to learn Rails, so I will use a lot of techniques/frameworks/open source projects along the way:
 I will use Twitter&#8217;s bootstrap framework to make the front end on the web look nicer
 I will use Markdown for editing ToDo item, as sometimes I want to be able to show links in my ToDo item.
 Many techniques from Railscasts&#8217; Ryan Bates. I strongly suggest you subscribe to his site for $9/month because he always bring to the community the best knowledge.
 Many techniques learned from Rails tutorial book by Michael Hartl.
 Enough for the introduction, let&#8217;s get started.
 Warning: Part 1 is pretty long and does not contain any iOS code yet!!!
PART 1: THE SERVER RAILS APP
Configuration
 I use Rails 3.2.3 and Ruby 1.9.2 for the server and iOS 5 SDK with Xcode 4.2 for the client. 
Todo project with Rails
 Let&#8217;s create the project using the rails new command
` 
$ cd work
$ rails new todo-app
$ cd todo-app
$ git init 
$ git add . 
$ git commit -m "Initial Rails project"
`
 At this time, we already have a running Rails app, if we want to see what&#8217;s already there, we can try:
$ rails server
 And then we can open the Chrome browser, type http://localhost:3000/ and the magic default Rails homepage will appear
 We don&#8217;t need just that, we&#8217;ll soon delete that homepage, for now, let&#8217;s open the project in the editor so that we can make some modifications
$ mate .
 My favorite editor of choice is TextMate, and here I use the mate command line to open the current directory, which is now the whole Rails application.
 Let&#8217;s edit the gemfile,  to add Twitter bootstrap gems to our project, we&#8217;ll use the twitter-bootstrap-rails gem because it provides us with some useful commands to speedup our process.
group :assets do
     ...
     gem 'twitter-bootstrap-rails'
end


 Then I&#8217;ll run the bundle command to install the new gem:
$ bundle install

 After that we&#8217;ll run the rails generate command to install the bootstrap
$ rails generate bootstrap:install 

 You&#8217;ll notice that there are some javascript, css and less files installed in your assets folder in the Rails app. That means that we are ready to have Bootstrap supported in our application. Now let&#8217;s create our first model view controller (MVC) ToDo item using the rails generate scaffold command, our todo will have only two fields: item for storing the todo, completed_at for storing the completion date, if it is nil then it&#8217;s not yet done, and then we migrate the database using the rake command. (You&#8217;ll notice that there&#8217;s something wrong here, the completed_at should be datetime, we&#8217;ll see how to fix our schema later)
$ rails generate scaffold todo item:text completed_at:date --skip-stylesheets
$ rake db:migrate

 We use the &#8212;skip-stylesheets command to avoid using the stylesheets generated by the scaffold, as we want to use the bootstrap stylesheets.
 The gem twitter-bootstrap-rails comes with some handy functions to enable our application to have the nice layout, we&#8217;ll use the rails generate bootstrap:layout command to have our application a fixed layout
$ rails generate bootstrap:layout application fixed

 At this time, if we run the rails server command, then we&#8217;ll see a nice layout applied to our todos page, it automatically adds a nav bar and a side bar to our project and apply the correct CSS classes to the page, http://localhost:3000/todos 
 
  We are really happy now, and we go ahead to apply the bootstrap&#8217;s themed to our todos resource, the gem we used has another command to generate the themes as follows:
$ rails generate bootstrap:themed todos

 When run this command, it will ask for the resolution of conflicts, but it&#8217;s ok to answer Y (YES) to all the questions. You can run the generate command with -f option to force all to override the conflicts with the ones from bootstrap. Now we have a pretty complete and beautiful Todo app, we can navigate to create new todo, update, delete them.
 
 Adding new todo item:
 
 And the new listing Todos page looks like this:
 
 Now let&#8217;s add some validation to our code, we don&#8217;t want a Todo item to not have any text, but before doing that, we run the test to see if the auto generated ones pass
$ rake test
Finished in 0.004226 seconds.

0 tests, 0 assertions, 0 failures, 0 errors, 0 skips

Finished in 0.440987 seconds.

7 tests, 10 assertions, 0 failures, 0 errors, 0 skips

 Let&#8217;s open the model file in app/models/todo.rb and add the validation for todo&#8217;s item
class Todo &lt; ActiveRecord::Base
  attr_accessible :completed_at, :item
  
  validates :item, presence: true
end

 Now if we open the rails console and try to create a new todo item without specifying the item text, then it will fail:
$ rails console --sandbox
Loading development environment in sandbox (Rails 3.2.3)
Any modifications you make will be rolled back on exit
1.9.2p290 :001 &gt; todo = Todo.new(item: "")
 =&gt; # 
1.9.2p290 :002 &gt; todo.save
   (0.3ms)  SAVEPOINT active_record_1
   (0.1ms)  ROLLBACK TO SAVEPOINT active_record_1
 =&gt; false 
1.9.2p290 :003 &gt; todo.valid?
 =&gt; false 
1.9.2p290 :004 &gt; todo.errors.full_messages
 =&gt; ["Item can't be blank"] 
1.9.2p290 :005 &gt; quit
   (0.2ms)  rollback transaction

 Let&#8217;s go ahead and add the alert when we successfully create/update a todo item. Open the app/views/layouts/application.html.erb and add the following code:
    &lt;div class="container"&gt;
      &lt;div class="content"&gt;
        &lt;% flash.each do |name, msg| %&gt;
          &lt;div class="alert alert-&lt;%= name == :notice ? "success" : "error" %&gt;"&gt;
            &lt;a class="close" data-dismiss="alert" href="#"&gt;x&lt;/a&gt;
            &lt;%= msg %&gt;
          &lt;/div&gt;
        &lt;% end %&gt;
        ...

 Now when we create/update an item, there will be an alert with the corresponding message and a close button to dismiss it.
 
 Next, we also want to add the simple_form gem into our application so that the validation of the fields in the form work. This gem will help us generate the correct stylesheets class for our form&#8217;s fields and additionally install Bootstrap CSS classes for us.
 First we need to add gem &#8216;simple_form&#8217; to the end of our gemfile:
...
gem 'simple_form'


 Then we run the simple_form:install command to generate the configuration and scaffold template:
$ rails generate simple_form:install --bootstrap
       exist  config
      create  config/initializers/simple_form.rb
      create  config/locales/simple_form.en.yml
      create  lib/templates/erb/scaffold/_form.html.erb
===============================================================================

  Be sure to have a copy of the Bootstrap stylesheet available on your
  application, you can get it on http://twitter.github.com/bootstrap.

  Inside your views, use the 'simple_form_for' with one of the Bootstrap form
  classes, '.form-horizontal', '.form-inline', '.form-search' or
  '.form-vertical', as the following:

    = simple_form_for(@user, :html =&gt; {:class =&gt; 'form-horizontal' }) do |form|

===============================================================================


 Next, we need to change form_for function to use simple_form_for and just let simple_form handle the correct types of form fields for us, like so:
# app/views/todos/_form.html.erb

&lt;%= simple_form_for @todo, :html =&gt; { :class =&gt; 'form-horizontal' } do |f| %&gt;

  &lt;%= f.input :item %&gt;
  &lt;%= f.input :completed_at %&gt;
   
  ...
&lt;% end %&gt;

# app/views/todos/_form_new.html.erb
&lt;%= simple_form_for @todo, html: { class: 'form-horizontal'} do |f| %&gt;
  
  &lt;%= f.input :item %&gt;
  
  ...
&lt;% end %&gt;


 Now that when an item is created with blank, then the error will be displayed nicely like this:
 
Use Markdown to highlight Todo items
 At this stage, we are quite happy now with our product, but here we want to go further, let&#8217;s enable our wonderful users to use Markdown to create/edit their Todo items, how great is that? When creating their Todo item, for example, &#8220;Read the Ruby on Rails tutorial&#8221;, they can easily create &#8220;Read the [Ruby on Rails tutorials](http://ruby.railstutorial.org)&#8221;, and the Todo item will be nicely converted to &#8220;Read the Ruby on Rails tutorials&#8221;
 Notice: in this section, I use the materials that come from the Pro version of railscasts.org 207 Syntax highlighting revised, please consider support Ryan Bates by subscribing to his site for only 9$/month.
 We are going to need two new gems, pygments.rb and redcarpet. Let&#8217;s go ahead and add them into our gemfile, remember to run the $ bundle install command after that:
# Gemfile
..
gem "pygments.rb", "~&gt; 0.2.12"
gem 'redcarpet'

  In order to use the Pygments.rb syntax highlighting, we need to add Pygments.css to our project, luckily, the function Pygments.css add this file to our project for us, so we are going to create a new file pygments.css.erb in our assets/stylesheets folder
# /app/assets/stylesheets/pygments.css.erb
&lt;%= Pygments.css %&gt;

 Now if we restart our server with $ rails server, we may encounter a crash of the whole rails application, it&#8217;s because Pygments is the syntax highlighting on the Server side written in Python, Ruby gem pygments.rb is the Ruby port of this Python program, it executes Python code using Python binary, if your system has the 32-bit only Python, you may encounter the error:
Could not open library '/Library/Frameworks/Python.framework/Versions/2.7/lib/libPython2.7.dylib': dlopen(/Library/Frameworks/Python.framework/Versions/2.7/lib/libPython2.7.dylib, 9): no suitable image found. Did find:
/Library/Frameworks/Python.framework/Versions/2.7/lib/libPython2.7.dylib: no matching architecture in universal wrapper
(in /Users/pnhoang/Developer/rails_casts/railscasts-episodes/episode-207/revised/highlighter-after/app/assets/stylesheets/pygments.css.erb)


 Download and install the 64bit binary Python will solve this problem.
 Next step is to add a new class HTMLwithPygments and a function markdown into our ApplicationHelper
#/app/helpers/application_helper.rb
module ApplicationHelper
  class HTMLwithPygments &lt; Redcarpet::Render::HTML
    def block_code(code, language)
      sha = Digest::SHA1.hexdigest(code)
      Rails.cache.fetch ["code", language, sha].join('-') do
        Pygments.highlight(code, lexer: language)
      end
    end
  end

  def markdown(text)
    renderer = HTMLwithPygments.new(hard_wrap: true, filter_html: true)
    options = {
      autolink: true,
      no_intra_emphasis: true,
      fenced_code_blocks: true,
      lax_html_blocks: true,
      strikethrough: true,
      superscript: true
    }
    Redcarpet::Markdown.new(renderer, options).render(text).html_safe
  end
end


 The functions defined in /app/helpers/ folder are automatically available in the controllers and the views, so we can call markdown from our show.html.erb and index.html.erb as below:
# /app/views/todos/index.html.erb
  ..
        &lt;td&gt;&lt;%= markdown todo.item %&gt;&lt;/td&gt;  
  ..

# /app/views/todos/show.html.erb
  ..
  &lt;dd&gt;&lt;%= markdown @todo.item %&gt;&lt;/dd&gt;
  ..

 Now we can edit and update our Todo items with Markdown, the results are shown in this figure:
 
Add Pagination into Todo items
 One more twist we would like to add is the pagination into Todo items list page, suppose, you have 20 items in your Todo list, you would like to show only 5 items per page. That&#8217;s easy to do with Rails. We&#8217;ll use two new gems &#8216;will_paginate&#8217; and the &#8216;bootstrap-will_paginate&#8217; gem to configure &#8216;will_paginate&#8217; to use Bootstrap stylesheets, and as usual, after adding the new gem, we need to run the $ bundle install command and restart the server.
# file: Gemfile
...
gem 'will_paginate'

gem 'bootstrap-will_paginate'
 In order to use this gem, we just need to add a Ruby function call to will_paginate at the bottom of the index page.
# file: /app/views/todos/index.html.erb
...
&lt;%= will_paginate %&gt;

&lt;%= link_to t('.new', :default =&gt; t("helpers.links.new")),
            new_todo_path,
            :class =&gt; 'btn btn-primary' %&gt;


 and changing our controller to call the &#8216;paginate&#8217; function of the Todo model.
# file: /app/controllers/todos_controller.rb
  def index
    @todos = Todo.paginate(page: params[:page], per_page: 5)
    ...

 And now, we have our awesome pagination for Todo items:
 
Fixing the database schema
 I accidentally created the table todos with the column completed_at as date, it was wrong, either it should be a datetime column or it should be renamed completed and the data type is boolean. So let&#8217;s fix that before we go ahead on adding the Todo Lists to the database schema. The rule of thumb when handling errors in the schema is to create another migration to fix it.
 Let&#8217;s first generate the migration using the generate command:
# 
$ rails generate migration ChangeTodoTable

 When creating a migration to change a table&#8217;s structure, Rails does not support the change method so we need to define both the up and down functions. In the up function, we specify how we want to change the database forward, conversely, in the down function, we specify how to return back to the previous state. This implies that by doing an up and down, the database should come back to the current state. In our case, when we add a completed column with value true/false, we will populate the corresponding true/false value into column completed based on the completed_at date column, this requires us to do a loop through all rows in Todo table, after that, we will remove column completed_at. Hence the up function is as follows:
# db/migrate/20120521121851_change_todo_table.rb
class ChangeTodoTable &lt; ActiveRecord::Migration
  def up
    change_table :todos do |t|
      t.boolean :completed
      Todo.all.each do |todo|
        if todo.completed_at != nil
          todo.update_attributes! completed: true
        else
          todo.update_attributes! completed: false
        end        
      end
      t.remove :completed_at
    end
  end

  def down
    ...
  end
end

 With the up function in place, we need to set the attrs_accessible to completed in our model, otherwise Rails will complaint about mass assigned values error
# app/models/todo.rb
class Todo &lt; ActiveRecord::Base
  attr_accessible :completed_at, :item, :completed
  
  ...
end


 Now we can run the $ rake db:migrate command to see the changes reflected in the database. We can open the Rails console to see the changes in action.
# BEFORE MIGRATION

$ rails c
Loading development environment (Rails 3.2.3)
1.9.2p290 :001 &gt; Todo.first
  Todo Load (0.1ms)  SELECT "todos".* FROM "todos" LIMIT 1
 =&gt; #&lt;Todo id: 5, item: "Read the [Ruby on Rails Tutorials](http://ruby.rail...", created_at: "2012-05-16 16:14:05", updated_at: "2012-05-21 13:00:39", completed_at: "2012-05-21"&gt; 

$ rake db:migrate

# AFTER MIGRATION
$ rails c
Loading development environment (Rails 3.2.3)
1.9.2p290 :001 &gt; Todo.first
  Todo Load (0.1ms)  SELECT "todos".* FROM "todos" LIMIT 1
 =&gt; #&lt;Todo id: 5, item: "Read the [Ruby on Rails Tutorials](http://ruby.rail...", created_at: "2012-05-16 16:14:05", updated_at: "2012-05-21 13:20:39", completed: true&gt; 



 With the down function, we just need to do the reverse process, first we add the completed_at as date data type, then we loop through all Todo rows and update the completed_at with the latest date of updated_at. (Notice: this is not really correct down migration, though for us now, it&#8217;s not too important the exact completed_at date)
# db/migrate/20120521121851_change_todo_table.rb
class ChangeTodoTable &lt; ActiveRecord::Migration
  def up
    ...
  end

  def down
    change_table :todos do |t|
      t.date :completed_at
      Todo.all.each do |todo|
        if todo.completed == true
          todo.update_attributes! completed_at: todo.updated_at.to_date
        else
          todo.update_attributes! completed_at: nil
        end
      end
      t.remove :completed
    end    
  end
end


 If you want to try to rollback, just try $ rake db:rollback and now the database schema is the same as before. Though we don&#8217;t want to run it now. Just for completeness, we write the down function.
 After running the $ rake db:migrate command, we can remove the :completed_at from the attr_accessible of Todo model
# app/models/todo.rb
class Todo &lt; ActiveRecord::Base
  attr_accessible :item, :completed
  
  ...
end

 And also be able to remove the _form_new.html.erb from folder app/views/todos/, as now we don&#8217;t need a separate form for creating new Todo. In the app/views/todos/new.html.erb, we can revert back to use render :partial &#8216;form&#8217;
# 
...
&lt;%= render :partial =&gt; 'form' %&gt;

 Everywhere we have the completed_at, we should now change to completed, luckily because we use simple_form_for for our attributes, we don&#8217;t need to re-create the form&#8217;s field for completed. simple_form_for is intelligent enough to use the checkbox in place for completed field
# app/views/todos/show.html.erb
  &lt;dt&gt;&lt;strong&gt;&lt;%= model_class.human_attribute_name(:completed) %&gt;:&lt;/strong&gt;&lt;/dt&gt;
  &lt;dd&gt;&lt;%= @todo.completed %&gt;&lt;/dd&gt;

# app/views/todos/index.html.erb
...
      &lt;th&gt;&lt;%= model_class.human_attribute_name(:item) %&gt;&lt;/th&gt;
      &lt;th&gt;&lt;%= model_class.human_attribute_name(:completed) %&gt;&lt;/th&gt;
      &lt;th&gt;&lt;%= model_class.human_attribute_name(:created_at) %&gt;&lt;/th&gt;
...

        &lt;td&gt;&lt;%= markdown todo.item %&gt;&lt;/td&gt;
        &lt;td&gt;&lt;%= check_box_tag :completed, todo.completed.to_s,  todo.completed, disabled: true %&gt;&lt;/td&gt;
        &lt;td&gt;&lt;%=l todo.created_at %&gt;&lt;/td&gt;


Add Todo lists to database schema
 We are almost ready with the Todo items so far, but as our Todo items grow, we need to organize the Todo items into lists. The next iteration we will make is to generate the scaffold for Todo lists
$ rails generate scaffold List name:string --skip-stylesheets

$ rails generate bootstrap:themed lists -f
 With the generate scaffold command, we don&#8217;t want to generate the scaffold stylesheets, so we pass the option &#8212;skip-stylesheets to the generator. Right after creating the scaffold, we want to apply the Bootstrap theme into the List views, so we run the generate bootstrap:themed command with -f option to force the changes in case there is conflict.
 We need to have a reference from Todo item table to List table, so we create a database migration and then modify the change function
$ rails generate migration AddReferencesToTodo

# db/migrate/add_reference_to_todo.rb
class AddReferencesToTodo &lt; ActiveRecord::Migration
  def change
    change_table :todos do |t|
      t.references :list
    end
  end
end

 In the model classes, we need to define some relationships: a List has many Todos, and conversely, Todo belongs to a List. We also declare the relationship between Lists and Todos with dependent: :destroy, because  we want to delete all of a list&#8217;s Todo items whenever we delete a list. This declaration is necessary in the parent item, not the child item.
# app/models/list.rb
class List &lt; ActiveRecord::Base
  attr_accessible :name
  
  has_many :todo, dependent: :destroy
end

# app/models/todo.rb
class Todo &lt; ActiveRecord::Base
  ...
  belongs_to :list
end

 And we would like to have the default value for completed as false instead of nil. First we need to add a callback to the after_initialize event, this callback function will then initialize the values of the instance of the class. Here&#8217;s the full Todo model up to this point
class Todo &lt; ActiveRecord::Base
  attr_accessible :item, :completed
  after_initialize :default_values
  
  validates :item, presence: true
  belongs_to :list
  
  private
    def default_values
      self.completed ||= false
    end
end


Update the routes to nested resources
 With our model ready, we can now update the routes to have nested resources. The concept is simple, one list has many todo items, so Todo items should be included in lists. In Rails routing, we do as follows
# /config/routes.rb
  resources :lists do
    resources :todos
  end

 We can see all the routes that Rails created for us with $ rake routes command. These includes 7 restful resource routes for parent element: list and 7 restful resource routes for child element: todo within a list. The child element is accessed by using the /lists/:list_id/ path, all Todo items path starts with this prefix.
$ rake routes
        list_todos GET    /lists/:list_id/todos(.:format)          todos#index
                   POST   /lists/:list_id/todos(.:format)          todos#create
     new_list_todo GET    /lists/:list_id/todos/new(.:format)      todos#new
    edit_list_todo GET    /lists/:list_id/todos/:id/edit(.:format) todos#edit
         list_todo GET    /lists/:list_id/todos/:id(.:format)      todos#show
                   PUT    /lists/:list_id/todos/:id(.:format)      todos#update
                   DELETE /lists/:list_id/todos/:id(.:format)      todos#destroy
             lists GET    /lists(.:format)                         lists#index
                   POST   /lists(.:format)                         lists#create
          new_list GET    /lists/new(.:format)                     lists#new
         edit_list GET    /lists/:id/edit(.:format)                lists#edit
              list GET    /lists/:id(.:format)                     lists#show
                   PUT    /lists/:id(.:format)                     lists#update
                   DELETE /lists/:id(.:format)                     lists#destroy

 The effect of adding nested resources into Todo items is that now we are not able to access Todo items anymore. There&#8217;s no way to create/edit/show/list todo items at the moment. However, adding this nested resource allows us to have a lot of new paths to access the todo items from the list. For example, we can see from above, to get the list of todo items of a specific list, we have the list_todos GET, this means that we can use the list_todos_path(@list) or list_todos_url(@list) to access the Todo list index page of a list.
 We&#8217;ll make a small change to the show method of lists_controller to have a way to go back and forth. Let&#8217;s use Twitter boostrap&#8217;s breadcrumb to do this.
# /views/lists/show.html.erb
&lt;%- model_class = @list.class -%&gt;
&lt;ul class="breadcrumb"&gt;
  &lt;li&gt;
    &lt;%= link_to 'My Lists', lists_path() %&gt;
    &lt;span class="divider"&gt;/&lt;/span&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;%= link_to 'Edit This List', list_todos_path(@list) %&gt;
    &lt;span class="divider"&gt;/&lt;/span&gt;
  &lt;/li&gt;
  &lt;li class="active"&gt;
    &lt;a href="#"&gt;Current List&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;&lt;%=t '.title', :default =&gt; model_class.model_name.human %&gt;&lt;/h1&gt;
...

 While we are at show view, we add a method to add new Todo items and to view the existing Todo items if any. In case there is todo item, we want to render the whole collection, Rails will enumerate each item in the collection and apply the render partial on each item. As a result, we need to create a new partial _todo.html.erb in app/views/todos folder
&lt;% if @list.todos.any? %&gt;
  &lt;h2&gt;Todo items&lt;/h2&gt;
  &lt;%= render @list.todos %&gt;
&lt;% end %&gt;

&lt;h2&gt;Add todo item&lt;/h2&gt;
&lt;%= render "todos/form"%&gt;

 When displaying the Todo items, we also want to use Markdown to highlight its syntax. Besides, for completed todo item, we will use Rails&#8217;s check_box_tag function to display a checkbox aside. Currently, we will disable this checkbox, as we have not had yet the Ajax function to enable checking/unchecking the completed status of a Todo item.
# app/views/todos/_todo.html.erb
&lt;%- model_class = todo.class -%&gt;

&lt;dl class="dl-horizontal"&gt;
  &lt;dt&gt;&lt;strong&gt;&lt;%= model_class.human_attribute_name(:item) %&gt;:&lt;/strong&gt;&lt;/dt&gt;
  &lt;dd&gt;&lt;%= markdown todo.item %&gt;&lt;/dd&gt;
  &lt;dt&gt;&lt;strong&gt;&lt;%= model_class.human_attribute_name(:completed) %&gt;:&lt;/strong&gt;&lt;/dt&gt;
  &lt;dd&gt;&lt;%= check_box_tag :completed, todo.completed.to_s, todo.completed, disabled: true %&gt;&lt;/dd&gt;
&lt;/dl&gt;

 The command render todos/forms use a partial in app/views/lists called _form.html.erb. In this form, we will use simple_form_for to simplify the form generation. It comes with default error management on each form fields compatible with bootstrap
# app/views/lists/_form.html.erb
&lt;%= simple_form_for @list, :html =&gt; { :class =&gt; 'form-horizontal' } do |f| %&gt;
  &lt;%= f.input :name %&gt;
  &lt;div class="form-actions"&gt;
    &lt;%= f.button :submit, :class =&gt; 'btn-primary' %&gt;
    &lt;%= link_to t('.cancel', :default =&gt; t("helpers.links.cancel")),
                lists_path, :class =&gt; 'btn' %&gt;
  &lt;/div&gt;
&lt;% end %&gt;


 Now we should be able to add new Todo items to the List and view all of a list&#8217;s items. We can use Markdown syntax to add our Todo item, an example is shown below:
 
 And here&#8217;s the result in the listings page:
 
 Advertisement: I&#8217;ll be participating in this year&#8217;s WWDC event. I would be very happy to meet all of you. Follow me on Twitter: @pnhoang
Fixing the Todo items controller
 We are now able to view the list and add items into it. However, we would like to fix the existed Todo item controller that we already did. The first one is the index, instead of directly getting the Todo from the params[:todo_id], we now have to first get the list from params[:list_id] and then use this list to find the todo items. 
# app/controllers/todos_controller.rb
  def index
    @list = List.find(params[:list_id])
    @todos = @list.todos.paginate(page: params[:page], per_page: 5)
    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @list }
    end
  end


 In the view page, we need to replace the @todos variable with @list.todos, and the corresponding paths, for example, todo_path(@todo) will be list_todo_path(@list, todo) and edit_todo_path(@todo) will be edit_list_todo_path(@list, todo), new_todo_path will be new_list_todo_path. For reference, here is the full index page
&lt;%- model_class = Todo.new.class -%&gt;
&lt;ul class="breadcrumb"&gt;
  &lt;li&gt;
    &lt;%= link_to 'My Lists', lists_path() %&gt;
    &lt;span class="divider"&gt;/&lt;/span&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;%= link_to 'View This List', list_path(@list) %&gt;
    &lt;span class="divider"&gt;/&lt;/span&gt;
  &lt;/li&gt;
  &lt;li class="active"&gt;
    &lt;a href="#"&gt;Current List&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;&lt;%= @list.name %&gt;&lt;/h1&gt;
&lt;table class="table table-striped"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;%= model_class.human_attribute_name(:id) %&gt;&lt;/th&gt;
      &lt;th&gt;&lt;%= model_class.human_attribute_name(:item) %&gt;&lt;/th&gt;
      &lt;th&gt;&lt;%= model_class.human_attribute_name(:completed) %&gt;&lt;/th&gt;
      &lt;th&gt;&lt;%= model_class.human_attribute_name(:created_at) %&gt;&lt;/th&gt;
      &lt;th&gt;&lt;%=t '.actions', :default =&gt; t("helpers.actions") %&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;% @todos.each do |todo| %&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;%= link_to todo.id, list_todo_path(@list, todo) %&gt;&lt;/td&gt;
        &lt;td&gt;&lt;%= markdown todo.item %&gt;&lt;/td&gt;
        &lt;td&gt;&lt;%= check_box_tag :completed, todo.completed.to_s,  todo.completed, disabled: true %&gt;&lt;/td&gt;
        &lt;td&gt;&lt;%=l todo.created_at %&gt;&lt;/td&gt;
        &lt;td&gt;
          &lt;%= link_to t('.edit', :default =&gt; t("helpers.links.edit")),
                      edit_list_todo_path(@list, todo), :class =&gt; 'btn btn-mini' %&gt;
          &lt;%= link_to t('.destroy', :default =&gt; t("helpers.links.destroy")),
                      list_todo_path(@list, todo),
                      :method =&gt; :delete,
                      :confirm =&gt; t('.confirm', :default =&gt; t("helpers.links.confirm", :default =&gt; 'Are you sure?')),
                      :class =&gt; 'btn btn-mini btn-danger' %&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
    &lt;% end %&gt;
  &lt;/tbody&gt;
&lt;/table&gt;


&lt;%= will_paginate %&gt;

&lt;%= link_to t('.new', :default =&gt; t("helpers.links.new")),
            new_list_todo_path,
            :class =&gt; 'btn btn-primary' %&gt;


 We also edit the show action by first locating to the params[:list_id] for list variable, then from this list, locating the todo item with params[:id].
  def show
    @list = List.find(params[:list_id])
    @todo = @list.todos.find(params[:id])

    respond_to do |format|
      format.html # show.html.erb
      format.json { render json: @list }
    end
  end

 In the view page, we also need to change the paths
&lt;div class="form-actions"&gt;
  &lt;%= link_to t('.back', :default =&gt; t("helpers.links.back")),
              list_todos_path(@list), :class =&gt; 'btn'  %&gt;
  &lt;%= link_to t('.edit', :default =&gt; t("helpers.links.edit")),
              edit_list_todo_path(@list, @todo), :class =&gt; 'btn' %&gt;
  &lt;%= link_to t('.destroy', :default =&gt; t("helpers.links.destroy")),
              list_todo_path(@list, @todo),
              :method =&gt; 'delete',
              :confirm =&gt; t('.confirm', :default =&gt; t("helpers.links.confirm", :default =&gt; 'Are you sure?')),
              :class =&gt; 'btn btn-danger' %&gt;
&lt;/div&gt;

 We can repeat the process for other actions in the controller: new, edit, create, update, destroy. Here is the remaining of the todos controller
# app/controllers/todos_controller.rb
  ...
  def new
    @list = List.find(params[:list_id])
    @todo = @list.todos.new

    respond_to do |format|
      format.html # new.html.erb
      format.json { render json: @todo }
    end
  end

  def edit
    @list = List.find(params[:list_id])
    @todo = @list.todos.find(params[:id])
  end


  def create
    @list = List.find(params[:list_id])
    @todo = @list.todos.build(params[:todo])
    
    respond_to do |format|
      if @todo.save
        format.html { redirect_to list_todos_path(@list), notice: 'Todo item was successfully created.' }
        format.json { render json: @list, status: :created, location: @list }
      else
        format.html { render action: "new" }
        format.json { render json: @todo.errors, status: :unprocessable_entity }
      end
    end
  end


  def update
    @list = List.find(params[:list_id])
    @todo = @list.todos.find(params[:id])

    respond_to do |format|
      if @todo.update_attributes(params[:todo])
        format.html { redirect_to list_todo_url(@list, @todo), notice: 'Todo was successfully updated.' }
        format.json { head :no_content }
      else
        format.html { render action: "edit" }
        format.json { render json: @todo.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /todos/1
  # DELETE /todos/1.json
  def destroy
    @todo = Todo.find(params[:id])
    @todo.destroy

    respond_to do |format|
      format.html { redirect_to todos_url }
      format.json { head :no_content }
    end
  end

 Last thing we need to do is to change the form for creating, updating Todo item. We should have an array of two objects for @list and @todo, we would normally write simple_form_for [@list, @todo]. However, in the case of @todo is empty such as when creating a new Todo from the list view page, we need to populate the form with Todo item fields. We do that by calling @list.todos.build method.
# app/views/todos/_form.html.erb

&lt;%= simple_form_for [@list, if @todo.nil? then @list.todos.build else @todo end], :html =&gt; { :class =&gt; 'form-horizontal' } do |f| %&gt;

  &lt;%= f.input :item, input_html: {class: "span6", rows: 3}  %&gt;
  &lt;%= f.input :completed%&gt;

  &lt;div class="form-actions"&gt;
    &lt;%= f.submit 'Save', :class =&gt; 'btn btn-primary' %&gt;
    &lt;%= link_to t('.cancel', :default =&gt; t("helpers.links.cancel")),
                lists_path, :class =&gt; 'btn' %&gt;
  &lt;/div&gt;
&lt;% end %&gt;


 In the above, we also change the style class of item input, we use bootstrap&#8217;s grid system to expand our input text field to span6, and 3 rows.
 The index.html.erb and show.html.erb for todo items do not change because we just render the partial form.
Adding user authentication
 We are pretty happy now, we have our model with Todo lists and items, with item that supports Markdown syntax. However, we have not yet the user model. We would like to allow user to sign up, sign in and sign out. Upon sign up, user will be sign in immediately. On sign in, we want a way to restrict access to lists and todo items to only signed in users. Other users could not see the other user&#8217;s lists and items.
 First we need to create user model, for simplicity, here we just create user model with only email and password. The password column will be named password_digest, we use features of Rails 3.1 for handling secure password in the database. When defining has_secure_password, two columns  password and password_confirmation will be automatically created for us. 
# Terminal
$ rails generate resource user email:string password_digest:string
$ rake db:migrate

 Then we run the migration to create the schema in the database.
 In the user model, we need to define has_secure_password so Rails will handle the creation of the secure hash password_digest column and the related password and password_confirmation. We also want to specify the attr_accessible methods for :email, :password and :password_confirmation
class User &lt; ActiveRecord::Base
  attr_accessible :email, :password, :password_confirmation
  
  has_secure_password
  validate :password, presence: true
  validate :email, presence: true
end

 We also need to uncomment the bcrypt gem in the gem file for the has_secure_password to work
# /app/gemfile
...
gem 'bcrypt-ruby', '~&gt; 3.0.0'

 Within the users controller, we will create two actions: new and create, in order to create a new form for user sign up and handle form submission. The new action will be use to generate the form with simple_form_for and the create action to handle the form submission
class UsersController &lt; ApplicationController
  def new
    @user = User.new
  end

  def create
    @user = User.new(params[:user])
    if @user.save
      redirect_to root_url, notice: "Signed up!"
    else
      render "new"
    end
  end
end


 To show the form for sign up, as we said above, we will use simple_form_for to generate the form that is compatible with Twitter bootstrap and has the default error handling, which we already use throughout the article. Here we use three fields: email, password and password_confirmation
# app/views/users/new.html.erb
&lt;h1&gt;Sign Up&lt;/h1&gt;

&lt;%= simple_form_for(@user, html: { class: "form-horizontal"}) do |f| %&gt;
  &lt;%= f.input :email %&gt;
  &lt;%= f.input :password %&gt;
  &lt;%= f.input :password_confirmation %&gt;
  &lt;div class="form-actions"&gt;
  &lt;%= f.button :submit, class: "btn-primary"%&gt;
  &lt;%= submit_tag 'Cancel', type: 'reset', class: 'btn btn-danger'%&gt;
  &lt;/div&gt;
&lt;% end %&gt;


 Now we need a link to go to this sign up form. The form can now be accessible at /users/new path, however, we want to customize it a little bit, we want the link to be /signup. Let&#8217;s modify it in the routes.rb file
# config/routes.rb

  match '/signup', to: 'users#new'
  ...

 This declaration makes available the signup_path and signup_url to use in our views. Restarting the server and navigating to the http://localhost:3000/signup now and it works!
 
 Creating a new user by inserting an email and password with password confirmation inserted correctly, we will be able to create a new user in the database. 
 Now we need a way for users to sign in, we will use Rails session to store the current user_id of signed in user. We generate the sessions controller with three actions: new, create and destroy. The new action will be used for login form, the create action for handling login submission and destroy for signing out.
# Terminal
$ rails generate controller sessions new create destroy

 Again we change the routes to get prettier paths instead of sessions/new path and sessions/destroy path
# config/routes.rb
  match '/signin', to: 'sessions#new'
  match '/signout', to: 'sessions#destroy', via: :delete
  resources :sessions, only: :create
  ...

 We now create the Login form with two fields: email and password. This time we use the form_tag to sessions_path because we don&#8217;t have any model to use with simple_form_for and form_for. The form_tag gets a bit complicated because we have to put the code for Twitter bootstrap ourselves.
# app/views/sessions/new.html.erb
&lt;h1&gt;Log in&lt;/h1&gt;

&lt;%= form_tag sessions_path, class: 'form-horizontal' do %&gt;
  &lt;div class="control-group email"&gt;
    &lt;%= label_tag :email, nil, class: 'email control-label' %&gt;
    &lt;div class="controls"&gt;
      &lt;%= text_field_tag :email, params[:email], class: 'string email' %&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="control-group password"&gt;
    &lt;%= label_tag :password, nil, class: 'password control-label' %&gt;
    &lt;div class="controls"&gt;
      &lt;%= password_field_tag :password %&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="form-actions"&gt;
    &lt;%= submit_tag "Log in", class: 'btn btn-primary' %&gt;
    &lt;%= link_to 'Cancel', root_path, class: 'btn'%&gt;
  &lt;/div&gt;
&lt;% end %&gt;

 Now to handle the login form submission, we need to implement the create action for sessions controller. We will first find the email to find the user in the database and use the password from the form to authenticate this user only in case this user exists in the database. Once authorized, we want to save the :user_id in the session with user&#8217;s id. This session will be used to check if a user is signed in to the system or not.
# app/controllers/sessions_controller.rb
  def create
    user = User.find_by_email(params[:email])
    if user &amp;&amp; user.authenticate(params[:password])
      user.api_keys.create!
      session[:user_id] = user.id
      redirect_to lists_url, notice: "Logged in!"
    else
      flash.now.alert = "Invalid email or password"
      render "new"
    end
  end

 Navigating now to the http://localhost:3000/signin, we can see the form to enter email and password. If the email and password are entered incorrectly, the user will receive a &#8216;invalid email or password&#8217; message, otherwise, they would be noticed with &#8216;Logged in!&#8217;. Our signup, signin forms now work!
 While we are at the sessions controller, let&#8217;s also implement a way for user to sign out, just set the :user_id hash in session to nil, then redirecting to root_url and we&#8217;re done.
# app/controllers/sessions_controller.rb
  def destroy
    session[:user_id] = nil
    redirect_to root_url, notice: "Logged out!"
  end

 When user is signed in, we want them to navigate between pages in the application and if we don&#8217;t have any way to know if the user is signed in or not, then the user will have to signed in again. Let&#8217;s go ahead and define the current_user method in application_controller so all our controllers know who the current user is. We store this information in a local variable @current_user so the query into the database happens only once.
# app/controllers/application_controller.rb
  protect_from_forgery
private 
  def current_user
    @current_user ||= User.find(session[:user_id]) if session[:user_id]
  end
  helper_method :current_user
  ...

 The helper_method :current_user makes this method available also in the views.
Updating the application layout
 We have almost finished the signing mechanism, now we would like to display the links to users in the navigation menu. When user is not signed in, we display two links: sign in and sign up. When user is signed in, we show the link to sign out. This will be done using the dropdown menu provided by bootstrap. The code becomes larger in our application layout file, so let&#8217;s move it to a partial. We call it _header.html.erb, and in the application.html.erb we will render this partial
# app/views/layouts/application.html.erb
  &lt;body&gt;

    &lt;%= render 'layouts/header' %&gt;

    &lt;div class="container"&gt;
    ...

 Now we need to create the _header.html.erb in the app/views/layouts directory and make the change to the navigation menu. We change the name of the project to Markdown Todo, and use the root_path to link to the homepage, we check for the current_user, if the current user is signed in, then we display the dropdown with the menu to Account page, profile page, and settings page, also we display the sign out link. If user is not signed in, we just shown the signin_path and signup_path
# app/views/layouts/_header.html.erb
&lt;div class="navbar navbar-fixed-top"&gt;
  &lt;div class="navbar-inner"&gt;
    &lt;div class="container"&gt;
      &lt;a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse"&gt;
        &lt;span class="icon-bar"&gt;&lt;/span&gt;
        &lt;span class="icon-bar"&gt;&lt;/span&gt;
        &lt;span class="icon-bar"&gt;&lt;/span&gt;
      &lt;/a&gt;
      &lt;%= link_to "Markdown Todo", root_path, class: "brand" %&gt;
      &lt;div class="container nav-collapse"&gt;
        &lt;ul class="nav"&gt;
          &lt;li&gt;&lt;%= link_to("Home", root_path) %&gt;&lt;/li&gt;
          &lt;li&gt;&lt;%= link_to("About", "#") %&gt;&lt;/li&gt;
          &lt;li&gt;&lt;%= link_to("Blog", "http://pnhoang.tumblr.com") %&gt;&lt;/li&gt;
          
          &lt;% if current_user %&gt;
          &lt;li id="fat-menu" class="dropdown"&gt;
            &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown"&gt; Account &lt;b class="caret"&gt;&lt;/b&gt;
            &lt;/a&gt;
            &lt;ul class="dropdown-menu"&gt;
              &lt;li&gt;&lt;%= link_to "Profile", current_user %&gt;&lt;/li&gt;
              &lt;li&gt;&lt;%= link_to "Settings", edit_user_path(current_user)%&gt;&lt;/li&gt;
              &lt;li class="divider"&gt;&lt;/li&gt;
              &lt;li&gt;
                &lt;%= link_to "Sign out", signout_path, method: :delete %&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;% else %&gt;
            &lt;li&gt; &lt;%= link_to "Sign in", signin_path %&gt;&lt;/li&gt;
            &lt;li&gt; &lt;%= link_to "Sign up", signup_path %&gt; &lt;/li&gt;
          &lt;% end %&gt;
        &lt;/ul&gt;
      &lt;/div&gt;&lt;!--/.nav-collapse --&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

 We also want to move the head into a separate partial call _head.html.erb so the application layout code is simpler.
# app/views/layouts/application.html.erb
  &lt;head&gt;
    &lt;%= render 'layouts/head' %&gt;
  &lt;/head&gt;

 The _head.html.erb partial does not contain any new code. We show it here for reference:
# app/views/layouts/_head.html.erb

&lt;meta charset="utf-8"&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;title&gt;&lt;%= content_for?(:title) ? yield(:title) : "Markdown Todo" %&gt;&lt;/title&gt;
&lt;%= csrf_meta_tags %&gt;

&lt;!-- Le HTML5 shim, for IE6-8 support of HTML elements --&gt;
&lt;!--[if lt IE 9]&gt;
&lt;script src="http://html5shim.googlecode.com/svn/trunk/html5.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;![endif]--&gt;

&lt;%= stylesheet_link_tag "application", :media =&gt; "all" %&gt;

&lt;link href="images/favicon.ico" rel="shortcut icon"&gt;
&lt;link href="images/apple-touch-icon.png" rel="apple-touch-icon"&gt;
&lt;link href="images/apple-touch-icon-72x72.png" rel="apple-touch-icon" sizes="72x72"&gt;
&lt;link href="images/apple-touch-icon-114x114.png" rel="apple-touch-icon" sizes="114x114"&gt;

 Now we would like to restrict access to lists to only signed in users (later on we will make changes to the schema to restrict access to only the correct user that signed in). Within our lists_controller and todos_controller, we can add the before_filter :authorize
# app/controllers/lists_controller.rb
class ListsController &lt; ApplicationController
  before_filter :authorize
  ...

# app/controllers/todos_controller.rb
class TodosController &lt; ApplicationController
  before_filter :authorize
  ...

 The authorize method in the application controller is just as simple as checking the current_user variable, if it is nil then we redirect to the sign in page.
# app/helpers/application_controller.rb
  def authorize
    redirect_to signin_url, alert: "Not authorized" if current_user.nil?
  end

 Now if we tried to navigate to lists index page without signing in, we will be redirected to the home page.
Adding static pages into the project
 Up to now our root page is still the lists page where everyone if logged in can see all the todo lists and todo items. That is not quite right, we&#8217;ll fix it later. Now we want to make a nice welcome page to our project and make it the default root page.
 Let&#8217;s start by creating a new controller
# Terminal
$ rails generate controller static_pages home about

 The home page will have a hero-unit in a div with a big welcome and some sections. You can make it as fancy as you want.
# app/views/static_pages/home.html.erb
&lt;div class="hero-unit"&gt;
  &lt;h1&gt;Welcome to Markdown Todo&lt;/h1&gt;
  &lt;p&gt; Your Todo Items are awesome with Markdown! 
  &lt;/p&gt;
  &lt;p&gt;
    Use all the available syntax at &lt;a alt="Markdown" href="http://daringfireball.net/projects/markdown"&gt; Markdown project&lt;/a&gt; to create your Todo items
  &lt;/p&gt;
  &lt;p&gt;
    &lt;%= link_to "Sign up now !", signup_path, class: 'btn btn-primary btn-large' %&gt;
&lt;/div&gt;

 The important thing is to change the routes config to the new controller&#8217;s action accordingly and remove the public/index.html
# config/routes.rb
  # You can have the root of your site routed with "root"
  # just remember to delete public/index.html.
  root :to =&gt; 'static_pages#home'

 Our new nice home page:
 
Enabling JSON API
 We have almost finished our application, let us now enable the JSON api so client applications can access our server app. JSON is by default configured with Rails app, when we create a scaffold, JSON is already enabled. Our problem is that we have use the authorize function to restrict access on the web using session. But with an API, we could not use the session, we need a way for the client application to specify authorization token in the header. An example is shown below
# Terminal
$ curl http://localhost:3000/lists -H 'Authorization: Token token="34b9d9eb4943786a791aecb366d91613"'

 We go ahead and create a new model to keep the access_token for a user id and run the migration
# Terminal
$ rails generate model api_key access_token:string user_id:integer
$ rake db:migrate

 We add the has_many and belongs_to relationship into user and api_key model respectively
# app/models/user.rb
  has_many :api_keys

# app/models/api_key.rb
  belongs_to :user

 For the ApiKey class, we add a hook to before_create to generate the access token on object creation. The access_token is generated using the Ruby&#8217;s SecureRandome.hex function
# app/models/api_key.rb
class ApiKey &lt; ActiveRecord::Base
  before_create :generate_access_token
  belongs_to :user
  
private
  def generate_access_token
    begin
      self.access_token = SecureRandom.hex
    end while self.class.exists?(access_token: access_token)
  end
end

 So now when user registers to the application, we will call the user.api_keys.create! function to create the new api_key for that user
# app/controllers/sessions_controller.rb
  def create
    user = User.find_by_email(params[:email])
    if user &amp;&amp; user.authenticate(params[:password])
      user.api_keys.create!
      session[:user_id] = user.id
      redirect_to lists_url, notice: "Logged in!"
    else
      flash.now.alert = "Invalid email or password"
      render "new"
    end
  end


 Now we can rewrite the authorize function for inclusion of JSON format to use the Rails&#8217;s authenticate_or_request_with_http_token function and check on the existence of user&#8217;s api_keys with the specific access_token provided. The authenticate function does not rely on current_user variable, but instead checking the user_id param and the corresponding token to grant access.
# app/controllers/application_controller.rb
  def authorize
    case request.format
    when Mime::JSON, Mime::XML, Mime::ATOM      
      authenticate_or_request_with_http_token do |token, options|
        user = User.find(params[:user_id])
        if user
          user.api_keys.exists?(access_token: token)
        end
      end
    else  
      redirect_to signin_url, alert: "Not authorized" if current_user.nil?
    end
  end

 We make a page for user to view his id and access_token. This page should be visible to only the user himself not any one else. To handle this, we define a new function in application controller called correct_user in which we check the params of user&#8217;s id, find the user based on this id and compare with the current signed in user.
# app/controllers/application_controller.rb
  def correct_user
    @user ||= User.find(params[:id])
    redirect_to(root_path) unless current_user?(@user)
  end

 This function is then called by the before_filter, and applied to only the show action
# app/controllers/user_controller.rb
class UsersController &lt; ApplicationController
  # we want to make a profile page for user to see his api_key
  before_filter :correct_user, only: :show
  
  ...

  def show
    @user = User.find(params[:id])
  end


 Our show page is simply a page to display user&#8217;s information along with the access_token
# app/views/users/show.html.erb
&lt;section class="row"&gt;
  &lt;h1&gt;Welcome: &lt;%= @user.email %&gt;&lt;/h1&gt;
  &lt;p class="intro"&gt;Your current access_token: &lt;%= @user.api_keys.first.access_token %&gt;&lt;/p&gt;
  &lt;p&gt; Your user_id: &lt;%= @user.id %&gt; &lt;/p&gt;
&lt;/section&gt;

 At this point, we are ready to expose the JSON API to the world and to build the iPhone client on the API. We&#8217;ll do that in the second part of this tutorial. Stay tuned! If you like the tutorial, follow me on Twitter @pnhoang to get the latest updates about the project.